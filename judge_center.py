# 以下代码判断了FPL预测的是矩形的中心框，辅助代码，对模型无作用
import numpy as np

# 骨架节点数据
skeleton_data = [[385.97, 383.022, 0.283742], [344.005, 385.913, 0.932527], [362.25, 388.497, 0.885327],
                 [362.487, 424.949, 0.833232], [346.722, 448.436, 0.56447], [323.392, 385.864, 0.895088],
                 [338.911, 422.297, 0.339168], [357.132, 437.984, 0.144912], [346.777, 448.519, 0.69486],
                 [362.36, 484.926, 0.451664], [354.508, 536.997, 0.334144], [323.32, 448.392, 0.637457],
                 [372.753, 490.022, 0.23106], [320.674, 531.833, 0.169965], [365.123, 367.624, 0.34559],
                 [0.0, 0.0, 0.0], [362.411, 365.124, 0.884795], [344.042, 365.025, 0.316139]]

# 将骨架节点数据转换为Numpy数组
skeleton_np = np.array(skeleton_data)

# 忽略全为0的点，因为它们可能代表缺失的节点
valid_skeleton = skeleton_np[np.all(skeleton_np[:, :2] != 0, axis=1)]

# 计算x和y坐标的最小和最大值
x_min, x_max = valid_skeleton[:, 0].min(), valid_skeleton[:, 0].max()
y_min, y_max = valid_skeleton[:, 1].min(), valid_skeleton[:, 1].max()

# 计算矩形框的中心
rect_center = np.array([(x_min + x_max) / 2, (y_min + y_max) / 2])

# 给定的坐标
given_coord = np.array([335.04849999999999, 448.45550000000003])

# 计算出的中心与给定坐标的比较
print(rect_center, given_coord)
